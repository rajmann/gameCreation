"""
@author: richard mann, nerdle

File inputs:
    - Solved cross nerdle puzzles generated by crossnerd_generator_1_answer.py.  File name = [fileStem]_answers.json
    - Word lists.  This time we use word lists that include leading zeros to make sure that there isn't a 'true' solution as well as a second with leading zeros.  These files have -z included in the file name.

Algorithm:
    - Loop through solved puzzles and remove as many digits as possible whilst still ensuring it is solvable without guessing and there is only one possible solution:
        - Randomly remove a digit
        - Check that puzzle is still solvable uniquely treating all across and down words independently
        - (i.e. only one possible answer from word list helps fill a gap, with at least one such gap somewhere in puzzle iteratively until solved)
        - Keep removing a digit until one can't be removed 10 times in a row
        - Final section sees if any cells at an intersection of two words can be removed because there is only one such value that solves both at once
    - Only word lists up to 9 specified.  
        
        
Difficulty grading:
        - Difficulty grading calculated for each puzzle as follows:

            - difficultyScore is based on 
            (a) replacements = the number of cells that need to be filled
            (b) nPlus = number of + signs in puzzle
            (b) nMinus = number of - signs in puzzle
            (b) nMultply = number of * signs in puzzle
            (b) nDivide = number of / signs in puzzle
            
            difficultyScore = 6.97*replacements+174.6+(-46.2*nPlus-46.8*nMinus+65.2*nDivide+7.5*nMultiply+12.74*0.9

            coefficients are based on a an analysis of average time to solve each puzzle and a regression model from first batch of puzzles                                                     

        - All puzzles assigned to a day based on difficultyScore and size:

            R7C7: difficulty=0 (Monday)
            R8C8/R9C9:
                if difficultyScore > 403: difficulty=4 (Friday)
                elif difficultyScore > 382: difficulty=3 (Thursday)
                elif difficultyScore > 354: difficulty=2 (Wednesday)
                else difficulty=1 (Tuesday)
            R10C10
                if difficultyScore > 404: difficulty=6 (Saturday)
                else: difficulty=5 (Sunday)

            Puzzles then sorted by size & difficulty so it can be split into 7 equal size lists (one for each day) even if some mixing eg Mondays might move to Tuesdays / vice versa.
    
    
File output:
    - One 'question' puzzle for each 'answer' puzzle, always with only one possible solution and always solvable
    - n puzzles per pattern generated - see setting params
    - Questions saved to [filestem]_questions.json - see setting params
    - Day list providing index to 7 equal-length lists of increasing difficulty saved to [fileStem]_dayIndex.json
    
"""


import numpy as np
import re
import random
import cv2 #only required to visualise completed puzzles
import json
import sys
import pandas as pd

# setting params

#fileStem specifes .txt file to read in for puzzles and is retained as prefix for output file, in which case comment out call to 'visualise' function
fileStem = 'patterns7x7_to_10x10-x4'

fileAnswers=fileStem+'_answers.json'
fileQuestions=fileStem+'_questions.json'
fileDayIndex=fileStem+'_dayIndex.json'


def prt(cn):
    print()
    for x in cn:
        print(''.join(x))
    print()

def find_pos_quick(word, wordNew):
    #new function only tries to solve the row or column that one cell is trying to be removed from
    #full puzzle solution still run at the end of the creator
    
    #character can be removed if all words matching that pattern have the same character at the position of the char being removed
    
    #eg 2*_?_.   ? can be removed because everything with the patter 2*_ _ _ has an equals sign at that position.
    
    #wordstr="".join(word)
    #wordMatch = [x for x in wordslist[len(wordstr)] if re.search(wordstr.replace("_","([0-9]|[*+-=]|[\/])").replace("+","\+").replace("*","\*").replace("/","\/"), x) != None]

    #identify char being changed
    ix = [i for i,l in enumerate(word) if word[i]!=wordNew[i]]
    
    if len(ix)==1:
        ix=ix[0]
    else:
        print("ERROR - MORE THAN ONE CHAR CHANGED")
        sys.exit()
        
    #find all words that match word with char removed
    wordstrNew="".join(wordNew)
    wordMatchNew = [x for x in wordslist[len(wordstrNew)] if re.search(wordstrNew.replace("_","([0-9]|[*+-=]|[\/])").replace("+","\+").replace("*","\*").replace("/","\/"), x) != None]

    #check how many possibilities at the position being removed other than the one we are removing
    wordDiff = [x for x in wordMatchNew if x[ix]!=word[ix]]
    if((len(wordMatchNew)>0) & (len(wordDiff)==0)):
        return([word])
    
    #non-unique solution
    return([])

def find_pos_intersection(word1, wordNew1, word2, wordNew2):
    #can character be removed at an intersection
    #if so, there can be multiple across solutions or multiple down solutions, but only one solution in common    

    #identify char being changed
    ix1 = [i for i,l in enumerate(word1) if word1[i]!=wordNew1[i]]
    ix2 = [i for i,l in enumerate(word2) if word2[i]!=wordNew2[i]]
    
    if len(ix1)==1:
        ix1=ix1[0]
    else:
        print("ERROR - MORE THAN ONE CHAR CHANGED")
        sys.exit()

    if len(ix2)==1:
        ix2=ix2[0]
    else:
        print("ERROR - MORE THAN ONE CHAR CHANGED")
        sys.exit()
        
    #find all words that match word with char removed
    wordstrNew1="".join(wordNew1)
    wordMatchNew1 = [x for x in wordslist[len(wordstrNew1)] if re.search(wordstrNew1.replace("_","([0-9]|[*+-=]|[\/])").replace("+","\+").replace("*","\*").replace("/","\/"), x) != None]

    wordstrNew2="".join(wordNew2)
    wordMatchNew2 = [x for x in wordslist[len(wordstrNew2)] if re.search(wordstrNew2.replace("_","([0-9]|[*+-=]|[\/])").replace("+","\+").replace("*","\*").replace("/","\/"), x) != None]

    #check how many possibilities at the position being removed other than the one we are removing
    possChars1 = set([x[ix1] for x in wordMatchNew1])
    possChars2 = set([x[ix2] for x in wordMatchNew2])
    
    #item can be removed only if this is the only solution in BOTH directions
    possChars12 = list(set(possChars1).intersection(possChars2))
    if(len(possChars12)==1):
       if possChars12[0]!=word1[ix1]:
           print("only solution isn't the one we're looking for")
           sys.exit()
       else:
           print("intersection removable") 
           print("across possibles", [x if i!=ix1 else "@" for i, x in enumerate(wordNew1)], possChars1)
           print("down possibles", [x if i!=ix2 else "@" for i, x in enumerate(wordNew2)], possChars2)
           print("only intersection", possChars12)
           return(possChars12)
    
    #non-unique solution
    return([])

def find_pos(cn, acr, dow):
    #find possible solutions
    
    #loop through all across then all down words
    #find possible words that match letter pattern
    #if no possible solutions, return []
    #if one possible solution, update word in puzzle with that solution
    
    found = True
    difficulty=0
    solveList=[]
    while found:
        difficulty+=1
        found = False
        acrpos, dowpos = [], []
        for i, word in enumerate(acr):
            wordstr = ''.join(cn[word[0], word[1][0]:(word[1][1]+1)])
            print(i,wordstr)
            if '_' in wordstr:
                acrpos.append([x for x in wordslist[len(wordstr)] if re.search(wordstr.replace("_","([0-9]|[*+-=]|[\/])").replace("+","\+").replace("*","\*").replace("/","\/"), x) != None])
                if len(acrpos[i]) == 0:
                    #no solutions, give up and return 
                    print("no solutions point 1")
                    sys.exit() #return ([], np.nan, [])
                elif len(acrpos[i]) == 1:
                    #only 1 solution: adopt it
                    for m,k in enumerate(range(word[1][0],(word[1][1]+1))):
                        if cn[word[0], k] != list(acrpos[i][0])[m]:
                            solveList+=[{"R":word[0],"C":k,"A":list(acrpos[i][0])[m]}]
                    cn[word[0], word[1][0]:(word[1][1]+1)] = list(acrpos[i][0])
                    found = True
                else:
                    #more than one solution, adopt solution anyway for any digits where all solutions have same digit
                    for e in range(len(wordstr)):
                        if wordstr[e] == '_':
                            posdig = [x[e] for x in acrpos[i]]
                            if all(x==posdig[0] for x in posdig):
                                solveList+=[{"R":word[0],"C":word[1][0]+e,"A":posdig[0]}]
                                cn[word[0], word[1][0]+e] = posdig[0]
                                found = True
            else:
                acrpos.append([])
        for i, word in enumerate(dow):
            wordstr = ''.join(cn[word[1][0]:(word[1][1]+1), word[0]])
            if '_' in wordstr:
                dowpos.append([x for x in wordslist[len(wordstr)] if re.search(wordstr.replace("_","([0-9]|[*+-=]|[\/])").replace("+","\+").replace("*","\*").replace("/","\/"), x) != None])
                if len(dowpos[i]) == 0:
                    #no solutions, give up and return 
                    print("no solutions point 2")
                    sys.exit() #return ([], np.nan, [])

                elif len(dowpos[i]) == 1:
                    #only 1 solution: adopt it
                    for m,k in enumerate(range(word[1][0],(word[1][1]+1))):
                        if cn[k, word[0]] != list(dowpos[i][0])[m]:
                            solveList+=[{"R":k,"C":word[0],"A":list(dowpos[i][0])[m]}]
                    cn[word[1][0]:(word[1][1]+1), word[0]] = list(dowpos[i][0])
                    found = True
                else:
                    #more than one solution, adopt solution anyway for any digits where all solutions have same digit
                    for e in range(len(wordstr)):
                        if wordstr[e] == '_':
                            posdig = [x[e] for x in dowpos[i]]
                            if all(x==posdig[0] for x in posdig):
                                solveList+=[{"R":word[1][0]+e,"C":word[0],"A":posdig[0]}]
                                cn[word[1][0]+e, word[0]] = posdig[0]
                                found = True
            else:
                dowpos.append([])

        #remove solved words from the list
        for i in range(len(acr)-1,-1,-1):
            if len(acrpos[i]) <= 1:
                acr.pop(i)
                acrpos.pop(i)
        for i in range(len(dow)-1,-1,-1):
            if len(dowpos[i]) <= 1:
                dow.pop(i)
                dowpos.pop(i)
    for x in cn:
        if '_' in x:
            #not solvable 
            return ([], np.nan, [])
    return (cn, difficulty, solveList)

def gen(temp, acr, dow):
    #generate puzzle by removing one letter at at time

    #choose a random letter (from a random word across or down) and remove from puzzle
    #if only one possible solution, save puzzle
    #otherwise try again until 10 attempts do not change puzzle
    
    counter = 0
    irremovablesAcr = np.copy(temp)
    irremovablesAcrCount = 0
    irremovablesDow = np.copy(temp)
    irremovablesDowCount = 0
    replaceables = 0
    for row in temp:
        replaceables+=len([x for x in row if x not in '@ X'])
    print("replaceable cells:", replaceables) 
    while counter < replaceables:
        if random.randint(0,1):
            a = random.choice(acr)
            ilist = [x for x in range(a[1][0], a[1][1]+1) if (temp[a[0],x] != '_') & (irremovablesAcr[a[0],x] != '$')]
            if len(ilist)>0: 
                i = random.choice(ilist)
                tempc = np.copy(temp)
                tempc[a[0], i] = '_'
                irremovablesAcr[a[0], i] = '_'

                word = [temp[a[0],x] for x in range(a[1][0], a[1][1]+1)]
                wordNew = [tempc[a[0],x] for x in range(a[1][0], a[1][1]+1)]

                #don't attempt to remove cells from words > 9 chars as no wordlist
                if len(word)>9:
                    res = []
                else:                
                    res = find_pos_quick(word,wordNew)
                                
                #res, _, _ = find_pos(tempc.copy(), acr.copy(), dow.copy())
                if len(res)==0: 
                    irremovablesAcr[a[0], i] = '$'
                    irremovablesAcrCount+=1
                    print("cells not removable across:", irremovablesAcrCount)
                    #print(irremovablesAcr)
            else:
                print("all acrosses checked and irremovable") 
                res=[]
        else:
            a = random.choice(dow)
            ilist = [x for x in range(a[1][0], a[1][1]+1) if (temp[x,a[0]] != '_') & (irremovablesDow[x,a[0]] != '$')]
            if len(ilist)>0: 
                i = random.choice(ilist)
                tempc = np.copy(temp)
                tempc[i, a[0]] = '_'
                irremovablesDow[i,a[0]] = '_'

                word = [temp[x,a[0]] for x in range(a[1][0], a[1][1]+1)]
                wordNew = [tempc[x,a[0]] for x in range(a[1][0], a[1][1]+1)]


                #don't attempt to remove cells from words > 9 chars as no wordlist
                if len(word)>9:
                    res = []
                else:
                    res = find_pos_quick(word,wordNew)

                #res, _, _ = find_pos(tempc.copy(), acr.copy(), dow.copy())
                if len(res)==0: 
                    irremovablesDow[i,a[0]] = '$'
                    irremovablesDowCount+=1
                    print("cells not removable down:", irremovablesDowCount)
                    #print(irremovablesDow)
            else:
                print("all downs checked and irremovable") 
                res=[]
        if len(res):
            temp = tempc.copy()
            print("word, wordNew", word, wordNew)
            print("item removed, restarting counter") 
            #prt(temp)
            counter = 0
        else:
            counter += 1
            print("Attempt", counter, end="..")
            
    #try to solve        
    res, difficulty, solveList = find_pos(temp.copy(), acr.copy(), dow.copy())
    if len(res)==0:
        print("ERROR: CANNOT BE SOLVED") 
        sys.exit() 
    
    tempList = "".join(["".join(x) for x in temp])
    replacements = len(tempList)-len(tempList.replace("_",""))
    difficulty = {'rounds': difficulty, 'replacements': replacements}
    return (temp, difficulty, solveList)

def findWords(pattern):
    #get all across and down words from given pattern
    #format (col, (from,to)):
    #   across = [(0,(0,7)), (4,(0,7)), (7,(0,7))]
    #   down = [(0,(0,7)), (2,(0,7)), (4,(0,7)), (7,(0,7))]


    
    patternShape = [len(pattern[0]),len(pattern)]

    acrossList = []
    found=False
    for y in range(patternShape[1]):
        for x in range(patternShape[0]):
            if (found==False) & (pattern[y][x] not in " X@"):
                found=True
                start=[x,y]
                patternIn=''
                length=0
            if (found==True) & (pattern[y][x] not in " X@"):
                length+=1
                patternIn+=pattern[y][x]
            if (found==True) & (pattern[y][x] in " X@" or x == patternShape[0]-1):
                found=False
                if length>1:
                    acrossList+=[{'start':start, 'length':length, 'patternIn':patternIn}]
     
    across = [(x['start'][1], (x['start'][0],x['start'][0]+x['length']-1)) for x in acrossList]
    downList = []
    found=False
    for x in range(patternShape[0]):
        for y in range(patternShape[1]):
            if (found==False) & (pattern[y][x] not in " X@"):
                found=True
                start=[x,y]
                patternIn=''
                length=0
            if (found==True) & (pattern[y][x] not in " X@"):
                length+=1
                patternIn+=pattern[y][x]
            if (found==True) & (pattern[y][x] in " X@" or y == patternShape[1]-1):
                found=False
                if length>1:
                    downList+=[{'start':start, 'length':length, 'patternIn':patternIn}]

    down = [(x['start'][0], (x['start'][1],x['start'][1]+x['length']-1)) for x in downList]
                    
    return(across, down)

def findIntersections(across,down):
    #intersections [[row,col,acrId,acrPos,dowId,dowPos]]
    intersectionList = [] 
    for acrId, acr in enumerate(across):
        row = acr[0]
        (acrFrom,acrTo) = acr[1]
        for dowId, dow in enumerate(down):
            col = dow[0]
            (dowFrom,dowTo) = dow[1]

            if (acrFrom<=col) & (acrTo>=col) & (dowFrom<=row) & (dowTo>=row):
                acrPos = col-acrFrom
                dowPos = row-dowFrom
                intersectionList+=[{"row":row,"col":col,"acrId":acrId,"acrPos":acrPos,"dowId":dowId,"dowPos":dowPos}]
                
    return(intersectionList)
    
def visualise(crossnum):
    cellWidth=50
    patternShape = [len(crossnum[0]),len(crossnum)]
    
    puzzle = np.zeros((patternShape[1]*cellWidth,patternShape[0]*cellWidth,3)).astype(np.uint8)
    puzzle[:,:,:]=75 #slightly grey
    font = cv2.FONT_HERSHEY_SIMPLEX
    fontScale = 1
    color = (100,100,100)
    thickness = 1
    for y,row in enumerate(crossnum):
        for x,letter in enumerate(row):
            if letter in " X":
                #leave black
                pass

            elif letter == "@":
                puzzle[y*cellWidth:(y+1)*cellWidth,x*cellWidth:(x+1)*cellWidth,:]=0
            else:
                if letter == "_":
                    letter=""
                puzzle[y*cellWidth:(y+1)*cellWidth,x*cellWidth:(x+1)*cellWidth,:]=255
                (width, height),_ = cv2.getTextSize(letter, font, fontScale, thickness)
                cv2.putText(puzzle, letter, (x*cellWidth+int(cellWidth/2-width/2),y*cellWidth+cellWidth-int(cellWidth/2-height/2)),font, fontScale, color, thickness, cv2.LINE_AA)
                cv2.rectangle(puzzle, (x*cellWidth,y*cellWidth), ((x+1)*cellWidth,(y+1)*cellWidth), (0,0,0))
    return(puzzle)

def draw_complete(event,x,y,flags,param):
    cellWidth=50
    font = cv2.FONT_HERSHEY_SIMPLEX
    fontScale = 1
    color = (200,100,200)
    thickness = 1
    

    if event == cv2.EVENT_LBUTTONDOWN:
        print(x,y)
        x = int(np.floor(x/cellWidth))
        y = int(np.floor(y/cellWidth))
        print(x,y)
        cv2.rectangle(puzzle, (x*cellWidth,y*cellWidth), ((x+1)*cellWidth,(y+1)*cellWidth), (0,0,255))
        cv2.imshow('image',puzzle) # to display the characters
        print("press key")
        k = cv2.waitKey(0)
        print("pressed", k)
        
        
        (width, height),_ = cv2.getTextSize(chr(k), font, fontScale, thickness)
        puzzle[y*cellWidth:(y+1)*cellWidth,x*cellWidth:(x+1)*cellWidth,:]=255
        cv2.rectangle(puzzle, (x*cellWidth,y*cellWidth), ((x+1)*cellWidth,(y+1)*cellWidth), (0,0,0))
        cv2.putText(puzzle, chr(k) , (x*cellWidth+int(cellWidth/2-width/2),y*cellWidth+cellWidth-int(cellWidth/2-height/2)), font, fontScale, color, thickness, cv2.LINE_AA)
        cv2.imshow('image',puzzle) # to display the characters
        # Press q to stop writing

#Load all allowed word lists (up to length 9)
wordslist = {}
for i in range(3, 10):
    with open(r'input/nerdlewords-.txt'.replace('-',str(i)), 'r') as f:
        wordslist[i] = [x.replace('\n','') for x in f.readlines()]

#now with leading zeros - to ensure we don't create a question that can be solved with leading zeros
wordslist = {}
for i in range(3, 10):
    with open(r'input/nerdlewords-z.txt'.replace('-',str(i)), 'r') as f:
        wordslist[i] = [x.replace('\n','') for x in f.readlines()]

#check length errors
for l in range(3,10): 
    for n in range(0,10):
        errors = len([x for x in wordslist[l] if len(x)==n])
        if (n!=l) & (errors>0):
            print("ERRORS", l, n, errors)

#file lengths
for l in range(3,10): 
    print("LENGTH", l, len(wordslist[l]))

#add nnn=nnn
for l in range(10,10000):
    question = str(l)+"="+str(l)
    wordslist[len(question)]+=[question]

#file lengths
for l in range(3,10): 
    print("LENGTH", l, len(wordslist[l]))

#Load list of answers
with open('output/'+fileAnswers) as f:
    puzzleList = json.load(f)

questionList=[]

for j,puzzle in enumerate(puzzleList[:]):
    template=np.array(puzzle)

    #find words in template
    print()
    print()
    print()
    print()
    print("****puzzle", j)
    across, down = findWords(template)       
    intersectionList = findIntersections(across, down)
    crossnum, difficulty, solveList = gen(template, across, down)
    print() 
    print("difficulty:", difficulty) 
    prt(crossnum)

    intersectionList = findIntersections(across, down)
    question = crossnum
    
    replacements2=0
    solveList2=[]
    for intersection in intersectionList:
        acr = across[intersection['acrId']]
        dow = down[intersection['dowId']]
        word1 = [question[acr[0]][x] for x in range(acr[1][0],acr[1][1]+1)]
        word2 = [question[x][dow[0]] for x in range(dow[1][0],dow[1][1]+1)]
        if word1[intersection['acrPos']]=="_":
            print("intersection already blank")
        else:
            wordNew1 = word1.copy()
            wordNew2 = word2.copy()
            wordNew1[intersection['acrPos']]="_"
            wordNew2[intersection['dowPos']]="_"

            if (len(word1)<=9) & (len(word2)<=9):
                res = find_pos_intersection(word1, wordNew1, word2, wordNew2)
                if len(res):
                    print("intersection removable", acr[0],dow[0])
                    question[acr[0]][dow[0]]="~"
                    replacements2+=1
                    solve = {"R":acr[0],"C":dow[0],"A":template[acr[0],dow[0]]}

                    solveList2= [solve]+solveList2
                else:
                    print("intersection cannot be removed")
    difficulty['replacements2']=replacements2
    solveList = solveList2+solveList

    output = difficulty
    output['answer']=[list(x.copy()) for x in template]
    output['question']=[list(x.copy()) for x in crossnum]
    output['size']="R"+str(len(template))+"C"+str(len(template[0]))
    output['solveList']=solveList
    
    wordList = []
    n3digits = 0
    nPlus = 0
    nMinus = 0
    nDivide = 0
    nMultiply = 0
    for a in across:
        word = "".join(template[a[0]][a[1][0]:a[1][1]+1])
        n3 = len(re.findall('[0-9][0-9][0-9]', word))
        wordList+=[word]
        n3digits+=n3
        nPlus+=len(word)-len(word.replace("+",""))
        nMinus+=len(word)-len(word.replace("-",""))
        nDivide+=len(word)-len(word.replace("/",""))
        nMultiply+=len(word)-len(word.replace("*",""))
    for d in down:
        word = "".join([template[r][d[0]] for r in range(d[1][0],d[1][1]+1)])
        n3 = len(re.findall('[0-9][0-9][0-9]', word))
        wordList+=[word]
        n3digits+=n3
        nPlus+=len(word)-len(word.replace("+",""))
        nMinus+=len(word)-len(word.replace("-",""))
        nDivide+=len(word)-len(word.replace("/",""))
        nMultiply+=len(word)-len(word.replace("*",""))
    
    output['n3digits']=n3digits
    output['nPlus']=nPlus
    output['nMinus']=nMinus
    output['nDivide']=nDivide
    output['nMultiply']=nMultiply
    output['wordList']=wordList

    
    questionList+=[output]

    cv2.destroyAllWindows()
    puzzle=visualise(crossnum)    #hide this line if not running cv2
    cv2.waitKey(100)
    
    with open('output/'+fileQuestions, 'w') as f:
            json.dump(questionList, f)

#add difficulty calculation


for i,question in enumerate(questionList):
    difficultyScore = 6.97*question['replacements']+174.6+(-46.2*question['nPlus']-46.8*question['nMinus']+65.2*question['nDivide']+7.5*question['nMultiply']+12.74)*0.9
    print(i, difficultyScore)    
    #normal daily difficulty calculations
    if question['size']=="R7C7":
        difficulty=0
    elif question['size'] in "R8C8R9C9":
        if difficultyScore > 403:
            difficulty=4
        elif difficultyScore > 382:
            difficulty=3
        elif difficultyScore > 354:
            difficulty=2
        else:
            difficulty=1
    elif question['size'] in "R10C10":
        if difficultyScore > 404:
            difficulty=6
        else:
            difficulty=5

    questionList[i]['difficultyScore'] = difficultyScore
    questionList[i]['difficulty'] = difficulty
    
#sort list by size then difficulty

questionList.sort(key=lambda x: x.get('difficultyScore'))
#questionList.sort(key=lambda x: len(x.get('question')))

#chunk into 7 lists of increasing difficulty
mod7Length = len(questionList)
mod7Length = max(7,mod7Length - mod7Length%7)
weeks = max(1,int(mod7Length/7))

dayList = [questionList[i:i + weeks] for i in range(0, mod7Length, weeks)]

#randomise each list
dayList = [random.sample(item, len(item))  for item in dayList]

newDayList = []
#join back into one list
for i in range(weeks):
    for j in range(7):
        newDayList += [dayList[j][i]]



#generate day list index [note, in this case, day list index is simply in order of dayList but this approach allows flexibility for list to be reordered and still indexed]
gamesDayList = list(range(0,weeks*7))
gamesDayList = [gamesDayList[x*weeks:(x+1)*weeks] for x in range(7)]

#save dayList and index to files
with open('output/'+fileQuestions, 'w') as f:
        json.dump(newDayList, f)
with open('output/'+fileDayIndex, 'w') as f:
        json.dump(newDayList, f)



cv2.destroyAllWindows()    

'''
#analyse question list with histograms
questions = pd.DataFrame(questionList)
for size in range(7,11):
    hist = questions[questions['size']=='R'+str(size)+'C'+str(size)].hist(bins=7)
'''


